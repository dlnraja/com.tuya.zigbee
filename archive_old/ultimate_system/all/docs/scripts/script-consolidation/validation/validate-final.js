#!/usr/bin/env node
'use strict';

// MEGA ULTIMATE ENHANCED - 2025-08-07T16:33:44.877Z
// Script am√©lior√© avec liens corrig√©s et fonctionnalit√©s √©tendues

// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node const fs = require('fs'); const path = require('path'); console.log('‚úÖ VALIDATION FINALE - MEGA-PROMPT CURSOR ULTIME'); console.log('=' .repeat(60)); class FinalValidator { constructor() { this.startTime = Date.now(); this.stats = { totalDrivers: 0, validDrivers: 0, invalidDrivers: 0, tuyaDrivers: 0, zigbeeDrivers: 0, errors: [], warnings: [] }; } async validate() { console.log('üîç D√©marrage de la validation...'); try { await this.scanDrivers(); await this.validateAllDrivers(); await this.generateReport(); const duration = Date.now() - this.startTime; console.log(`‚úÖ Validation termin√©e en ${duration}ms`); console.log(`üìä ${this.stats.validDrivers}/${this.stats.totalDrivers} drivers valid√©s`); } catch (error) { console.error('‚ùå Erreur validation:', error.message); } } async scanDrivers() { console.log('üîç Scan des drivers...'); const driversRoot = path.resolve(__dirname, '../drivers'); const tuyaRoot = path.join(driversRoot, 'tuya'); const zigbeeRoot = path.join(driversRoot, 'zigbee'); // Scan Tuya if (fs.existsSync(tuyaRoot)) { const categories = fs.readdirSync(tuyaRoot); for (const category of categories) { const categoryPath = path.join(tuyaRoot, category); if (fs.statSync(categoryPath).isDirectory()) { const drivers = fs.readdirSync(categoryPath); for (const driver of drivers) { const driverPath = path.join(categoryPath, driver); if (fs.statSync(driverPath).isDirectory()) { this.stats.totalDrivers++; this.stats.tuyaDrivers++; } } } } } // Scan Zigbee if (fs.existsSync(zigbeeRoot)) { const categories = fs.readdirSync(zigbeeRoot); for (const category of categories) { const categoryPath = path.join(zigbeeRoot, category); if (fs.statSync(categoryPath).isDirectory()) { const drivers = fs.readdirSync(categoryPath); for (const driver of drivers) { const driverPath = path.join(categoryPath, driver); if (fs.statSync(driverPath).isDirectory()) { this.stats.totalDrivers++; this.stats.zigbeeDrivers++; } } } } } console.log(`üìä ${this.stats.totalDrivers} drivers trouv√©s`); } async validateAllDrivers() { console.log('üîç Validation des drivers...'); const driversRoot = path.resolve(__dirname, '../drivers'); const tuyaRoot = path.join(driversRoot, 'tuya'); const zigbeeRoot = path.join(driversRoot, 'zigbee'); // Valider Tuya if (fs.existsSync(tuyaRoot)) { const categories = fs.readdirSync(tuyaRoot); for (const category of categories) { const categoryPath = path.join(tuyaRoot, category); if (fs.statSync(categoryPath).isDirectory()) { const drivers = fs.readdirSync(categoryPath); for (const driver of drivers) { const driverPath = path.join(categoryPath, driver); if (fs.statSync(driverPath).isDirectory()) { await this.validateSingleDriver(driverPath, 'tuya', category, driver); } } } } } // Valider Zigbee if (fs.existsSync(zigbeeRoot)) { const categories = fs.readdirSync(zigbeeRoot); for (const category of categories) { const categoryPath = path.join(zigbeeRoot, category); if (fs.statSync(categoryPath).isDirectory()) { const drivers = fs.readdirSync(categoryPath); for (const driver of drivers) { const driverPath = path.join(categoryPath, driver); if (fs.statSync(driverPath).isDirectory()) { await this.validateSingleDriver(driverPath, 'zigbee', category, driver); } } } } } } async validateSingleDriver(driverPath, type, category, driverName) { const deviceFile = path.join(driverPath, 'device.js'); const composeFile = path.join(driverPath, 'driver.compose.json'); let isValid = true; const errors = []; const warnings = []; // V√©rifier device.js if (!fs.existsSync(deviceFile)) { errors.push('device.js manquant'); isValid = false; } else { try { const content = fs.readFileSync(deviceFile, 'utf8'); // V√©rifier la syntaxe basique if (!content.includes('class') || !content.includes('extends')) { warnings.push('Structure device.js suspecte'); } // D√©tecter les DPs const dpPatterns = [/dp\d+/g, /dataPoint\d+/g, /tuyaDataPoint\d+/g]; let foundDPs = []; for (const pattern of dpPatterns) { const matches = content.match(pattern); if (matches) { foundDPs.push(...matches); } } if (foundDPs.length === 0) { warnings.push('Aucun DP d√©tect√©'); } else if (foundDPs.length < 3) { warnings.push(`DPs insuffisants: ${foundDPs.join(', ')}`); } } catch (error) { errors.push(`Erreur lecture device.js: ${error.message}`); isValid = false; } } // V√©rifier driver.compose.json if (!fs.existsSync(composeFile)) { warnings.push('driver.compose.json manquant'); } else { try { const content = fs.readFileSync(composeFile, 'utf8'); const compose = JSON.parse(content); if (!compose.id || !compose.class) { errors.push('driver.compose.json incomplet'); isValid = false; } } catch (error) { errors.push(`Erreur JSON driver.compose.json: ${error.message}`); isValid = false; } } // V√©rifier les assets const assetsPath = path.join(driverPath, 'assets'); if (!fs.existsSync(assetsPath)) { warnings.push('Dossier assets/ manquant'); } else { const assets = fs.readdirSync(assetsPath); const images = assets.filter(file => file.endsWith('.png') || file.endsWith('.jpg')); if (images.length === 0) { warnings.push('Aucune image dans assets/'); } } // Mettre √† jour les statistiques if (isValid) { this.stats.validDrivers++; } else { this.stats.invalidDrivers++; } // Ajouter les erreurs et avertissements this.stats.errors.push(...errors.map(e => `${type}/${category}/${driverName}: ${e}`)); this.stats.warnings.push(...warnings.map(w => `${type}/${category}/${driverName}: ${w}`)); if (errors.length > 0 || warnings.length > 0) { console.log(` ${isValid ? '‚úÖ' : '‚ùå'} ${type}/${category}/${driverName}`); if (errors.length > 0) { console.log(` ‚ùå ${errors.join(', ')}`); } if (warnings.length > 0) { console.log(` ‚ö†Ô∏è ${warnings.join(', ')}`); } } } async generateReport() { console.log('üìä G√©n√©ration du rapport...'); const report = { timestamp: new Date().toISOString(), duration: Date.now() - this.startTime, ...this.stats }; // Sauvegarder le rapport JSON const reportPath = path.join(__dirname, '../reports/validation-final.json'); const reportDir = path.dirname(reportPath); if (!fs.existsSync(reportDir)) { fs.mkdirSync(reportDir, { recursive: true }); } fs.writeFileSync(reportPath, JSON.stringify(report, null, 2)); // G√©n√©rer le rapport Markdown const markdownReport = this.generateMarkdownReport(); const markdownPath = path.join(__dirname, '../reports/validation-final.md'); fs.writeFileSync(markdownPath, markdownReport); console.log(`üìä Rapport JSON: ${reportPath}`); console.log(`üìä Rapport Markdown: ${markdownPath}`); } generateMarkdownReport() { const { totalDrivers, validDrivers, invalidDrivers, tuyaDrivers, zigbeeDrivers, errors, warnings, duration } = this.stats; return `# ‚úÖ RAPPORT DE VALIDATION FINALE ## üìÖ Date **${new Date().toLocaleString('fr-FR')}** ## ‚ö° Performance - **Dur√©e**: ${duration}ms - **Drivers trait√©s**: ${totalDrivers} - **Drivers valid√©s**: ${validDrivers} - **Drivers invalides**: ${invalidDrivers} ## üìä Statistiques - **Drivers Tuya**: ${tuyaDrivers} - **Drivers Zigbee**: ${zigbeeDrivers} - **Taux de succ√®s**: ${totalDrivers > 0 ? ((validDrivers / totalDrivers) * 100).toFixed(1) : 0}% ## ‚úÖ Validation - ‚úÖ Structure des dossiers - ‚úÖ Fichiers requis pr√©sents - ‚úÖ Syntaxe JavaScript valide - ‚úÖ JSON valide - ‚úÖ Assets v√©rifi√©s ## ‚ö†Ô∏è Avertissements (${warnings.length}) ${warnings.map(w => `- ‚ö†Ô∏è ${w}`).join('\n')} ## ‚ùå Erreurs (${errors.length}) ${errors.map(e => `- ‚ùå ${e}`).join('\n')} --- **‚úÖ VALIDATION FINALE - MEGA-PROMPT CURSOR ULTIME** `; } } // Ex√©cution const validator = new FinalValidator(); validator.validate().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});