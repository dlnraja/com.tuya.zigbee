#!/usr/bin/env node
'use strict';

/**
 * INTELLIGENT BATTERY MANAGER
 * Gestion intelligente et reconnaissance des batteries partout dans le projet
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.join(__dirname, '..');

class IntelligentBatteryManager {
  constructor() {
    this.batteryPatterns = {
      // Types batteries connus
      types: {
        'CR2032': { voltage: 3.0, capacity: 225, typical_life: '2-3 years' },
        'CR2450': { voltage: 3.0, capacity: 620, typical_life: '3-5 years' },
        'CR123A': { voltage: 3.0, capacity: 1500, typical_life: '3-5 years' },
        'AAA': { voltage: 1.5, capacity: 1200, typical_life: '1-2 years' },
        'AA': { voltage: 1.5, capacity: 2850, typical_life: '2-4 years' },
        '9V': { voltage: 9.0, capacity: 565, typical_life: '1-2 years' }
      },
      
      // Patterns de d√©tection
      detection: {
        device_type: {
          button: ['CR2032'],
          remote: ['CR2032', 'AAA'],
          motion: ['CR2032', 'AAA'],
          door: ['CR2032', 'AAA'],
          window: ['CR2032', 'AAA'],
          smoke: ['AA', '9V'],
          leak: ['AAA', 'AA'],
          temperature: ['AAA', 'AA'],
          humidity: ['AAA', 'AA']
        },
        
        model_hints: {
          'TS0201': ['AAA', 'CR2032'],
          'TS0202': ['CR2032'],
          'TS0203': ['CR2032'],
          'TS0204': ['AAA', 'AA'],
          'TS0205': ['CR2032'],
          'TS0601': ['AAA', 'AA', 'CR2032']
        }
      },
      
      // Thresholds intelligents
      thresholds: {
        critical: 10,
        low: 20,
        warning: 30,
        good: 50,
        excellent: 80
      }
    };
    
    this.enrichments = [];
  }

  log(msg, icon = 'üîã') {
    console.log(`${icon} ${msg}`);
  }

  // D√©tecter type batterie intelligent
  detectBatteryType(driverName, model, capabilities) {
    const name = driverName.toLowerCase();
    const batteries = new Set();

    // Par nom driver
    for (const [keyword, types] of Object.entries(this.batteryPatterns.detection.device_type)) {
      if (name.includes(keyword)) {
        types.forEach(t => batteries.add(t));
      }
    }

    // Par model
    if (model && this.batteryPatterns.detection.model_hints[model]) {
      this.batteryPatterns.detection.model_hints[model].forEach(t => batteries.add(t));
    }

    // Par taille et forme
    if (name.includes('cr2032')) batteries.add('CR2032');
    if (name.includes('cr2450')) batteries.add('CR2450');
    if (name.includes('aaa')) batteries.add('AAA');
    if (name.includes('aa') && !name.includes('aaa')) batteries.add('AA');

    // D√©faut intelligent
    if (batteries.size === 0) {
      if (capabilities?.includes('button')) {
        batteries.add('CR2032');
      } else if (capabilities?.includes('alarm_motion')) {
        batteries.add('CR2032');
        batteries.add('AAA');
      } else {
        batteries.add('CR2032');
        batteries.add('AAA');
        batteries.add('AA');
      }
    }

    return Array.from(batteries);
  }

  // Calculer estimation dur√©e vie
  estimateBatteryLife(batteryType, deviceType) {
    const battery = this.batteryPatterns.types[batteryType];
    if (!battery) return 'Unknown';

    const name = deviceType.toLowerCase();
    
    // Ajuster selon usage
    if (name.includes('motion') || name.includes('pir')) {
      return '6-12 months (high usage)';
    } else if (name.includes('button') || name.includes('remote')) {
      return battery.typical_life;
    } else if (name.includes('door') || name.includes('window')) {
      return '1-2 years';
    } else if (name.includes('temperature') || name.includes('humidity')) {
      return '1-3 years';
    }

    return battery.typical_life;
  }

  // G√©n√©rer code monitoring batterie
  generateBatteryMonitoringCode(batteryTypes) {
    const thresholds = this.batteryPatterns.thresholds;
    return `
  /**
   * INTELLIGENT BATTERY MONITORING
   * Auto-generated by IntelligentBatteryManager
   */
  
  async monitorBattery() {
    try {
      const batteryLevel = this.getCapabilityValue('measure_battery');
      
      if (batteryLevel !== null && batteryLevel !== undefined) {
        // Battery level categorization
        if (batteryLevel <= ${thresholds.critical}) {
          this.setWarning('‚ö†Ô∏è CRITICAL: Battery ' + batteryLevel + '% - Replace immediately!');
          this.log('Battery CRITICAL:', batteryLevel + '%');
        } else if (batteryLevel <= ${thresholds.low}) {
          this.setWarning('Battery low: ' + batteryLevel + '% - Replace soon');
          this.log('Battery LOW:', batteryLevel + '%');
        } else if (batteryLevel <= ${thresholds.warning}) {
          this.log('Battery WARNING level:', batteryLevel + '%');
        } else {
          this.unsetWarning();
        }
        
        // Battery type info
        const supportedBatteries = ${JSON.stringify(batteryTypes)};
        this.log('Supported batteries:', supportedBatteries.join(', '));
        
        // Estimate remaining time
        if (batteryLevel <= 20) {
          const estimatedDays = Math.floor((batteryLevel / 20) * 30);
          this.log('Estimated remaining: ~' + estimatedDays + ' days');
        }
      }
    } catch (err) {
      this.error('Battery monitoring error:', err);
    }
  }
  
  /**
   * Battery change detection
   */
  async detectBatteryChange(oldValue, newValue) {
    try {
      // Detect battery replacement (jump from low to high)
      if (oldValue < 30 && newValue > 80) {
        this.log('üîã Battery replaced detected!');
        if (this.homey && this.homey.flow) {
          this.homey.flow.getDeviceTriggerCard('device_battery_changed')
            .trigger(this, { old_battery: oldValue, new_battery: newValue })
            .catch(err => this.error('Flow trigger error:', err));
        }
        
        // Reset warnings
        this.unsetWarning();
      }
    } catch (err) {
      this.error('Battery change detection error:', err);
    }
  }
`;
  }

  // Enrichir driver avec monitoring batterie
  async enrichDriver(driverPath) {
    const driverName = path.basename(driverPath);
    const composeFile = path.join(driverPath, 'driver.compose.json');
    const deviceFile = path.join(driverPath, 'device.js');

    if (!fs.existsSync(composeFile)) return false;

    try {
      const compose = JSON.parse(fs.readFileSync(composeFile, 'utf8'));
      
      // V√©rifier si batterie
      if (!compose.capabilities?.includes('measure_battery')) {
        return false;
      }

      let modified = false;

      // 1. Enrichir energy.batteries
      const batteryTypes = this.detectBatteryType(
        driverName,
        compose.zigbee?.manufacturerName,
        compose.capabilities
      );

      if (!compose.energy) {
        compose.energy = {};
        modified = true;
      }

      if (!compose.energy.batteries || compose.energy.batteries.length === 0) {
        compose.energy.batteries = batteryTypes;
        modified = true;
      }

      // 2. Ajouter settings batterie
      if (!compose.settings) {
        compose.settings = [];
      }

      const hasBatterySetting = compose.settings.some(s => 
        s.id === 'battery_threshold' || s.id === 'low_battery_threshold'
      );

      if (!hasBatterySetting) {
        compose.settings.push({
          type: 'group',
          label: { en: 'Battery Management', fr: 'Gestion Batterie' },
          children: [
            {
              id: 'low_battery_threshold',
              type: 'number',
              label: { 
                en: 'Low battery alert threshold',
                fr: 'Seuil alerte batterie faible'
              },
              hint: {
                en: 'Alert when battery drops below this level',
                fr: 'Alerte quand batterie descend sous ce niveau'
              },
              value: 20,
              min: 5,
              max: 50,
              units: '%'
            },
            {
              id: 'battery_reporting_interval',
              type: 'number',
              label: {
                en: 'Battery reporting interval',
                fr: 'Intervalle rapport batterie'
              },
              hint: {
                en: 'How often to check battery level (minutes)',
                fr: 'Fr√©quence v√©rification batterie (minutes)'
              },
              value: 60,
              min: 15,
              max: 1440,
              units: 'min'
            }
          ]
        });
        modified = true;
      }

      // 3. Sauvegarder compose
      if (modified) {
        fs.writeFileSync(composeFile, JSON.stringify(compose, null, 2) + '\n');
      }

      // 4. Enrichir device.js si existe
      if (fs.existsSync(deviceFile)) {
        let deviceCode = fs.readFileSync(deviceFile, 'utf8');
        
        // Ajouter monitoring si pas pr√©sent
        if (!deviceCode.includes('monitorBattery') && 
            !deviceCode.includes('INTELLIGENT BATTERY MONITORING')) {
          
          const monitoringCode = this.generateBatteryMonitoringCode(batteryTypes);
          
          // Ins√©rer avant dernier }
          const lastBrace = deviceCode.lastIndexOf('}');
          deviceCode = deviceCode.slice(0, lastBrace) + 
                      '\n' + monitoringCode + '\n' +
                      deviceCode.slice(lastBrace);
          
          fs.writeFileSync(deviceFile, deviceCode);
          modified = true;
        }
      }

      if (modified) {
        this.enrichments.push({
          driver: driverName,
          batteries: batteryTypes,
          lifetimeEstimate: this.estimateBatteryLife(batteryTypes[0], driverName)
        });
        this.log(`‚úÖ ${driverName} - ${batteryTypes.join(', ')}`, '  ');
      }

      return modified;
    } catch (err) {
      this.log(`‚ùå ${driverName}: ${err.message}`, '  ');
      return false;
    }
  }

  // Enrichir tous les drivers
  async enrichAllDrivers() {
    this.log('Enrichissement intelligent des batteries...', 'üîã');
    console.log('‚ïê'.repeat(70));

    const driversPath = path.join(ROOT, 'drivers');
    const drivers = fs.readdirSync(driversPath).filter(name => {
      return fs.statSync(path.join(driversPath, name)).isDirectory();
    });

    this.log(`${drivers.length} drivers √† analyser`);

    let enriched = 0;
    for (const driver of drivers) {
      const driverPath = path.join(driversPath, driver);
      if (await this.enrichDriver(driverPath)) {
        enriched++;
      }
    }

    this.log(`${enriched} drivers enrichis`, '‚úÖ');
    return enriched;
  }

  // G√©n√©rer rapport
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      statistics: {
        totalDrivers: this.enrichments.length,
        batteryTypes: {}
      },
      enrichments: this.enrichments,
      recommendations: []
    };

    // Statistiques par type
    for (const enrich of this.enrichments) {
      for (const battery of enrich.batteries) {
        report.statistics.batteryTypes[battery] = 
          (report.statistics.batteryTypes[battery] || 0) + 1;
      }
    }

    // Recommandations
    report.recommendations.push(
      'Replace batteries when level drops below 15%',
      'Check battery levels monthly for critical devices',
      'Keep spare batteries on hand for common types',
      'Use quality branded batteries for longer life'
    );

    const reportPath = path.join(ROOT, 'reports', 'INTELLIGENT_BATTERY_REPORT.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    return report;
  }

  // Ex√©cution
  async run() {
    console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                                                                    ‚ïë');
    console.log('‚ïë     INTELLIGENT BATTERY MANAGER - GESTION AVANC√âE                  ‚ïë');
    console.log('‚ïë                                                                    ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

    const startTime = Date.now();

    // Enrichir tous
    const enriched = await this.enrichAllDrivers();

    // G√©n√©rer rapport
    const report = this.generateReport();

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);

    // Rapport final
    console.log('\n' + '‚ïê'.repeat(70));
    console.log('üìä RAPPORT FINAL BATTERIES');
    console.log('‚ïê'.repeat(70));
    console.log(`\n‚è±Ô∏è  Temps: ${totalTime}s`);
    console.log(`üîã Drivers enrichis: ${enriched}`);
    console.log(`üìä Types batteries:`);
    
    for (const [type, count] of Object.entries(report.statistics.batteryTypes)) {
      console.log(`   - ${type}: ${count} drivers`);
    }

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('‚úÖ ENRICHISSEMENT BATTERIES TERMIN√â');
    console.log('‚ïê'.repeat(70) + '\n');

    return report;
  }
}

// Ex√©cuter
if (require.main === module) {
  const manager = new IntelligentBatteryManager();
  manager.run().catch(err => {
    console.error('Erreur fatale:', err);
    process.exit(1);
  });
}

module.exports = IntelligentBatteryManager;
