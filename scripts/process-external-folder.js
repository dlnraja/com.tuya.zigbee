// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node const fs = require('fs'); const path = require('path'); console.log('ðŸš€ PROCESS-EXTERNAL-FOLDER - TRAITEMENT COMPLET'); console.log('=' .repeat(60)); class ExternalFolderProcessor { constructor() { this.startTime = Date.now(); this.targetFolder = 'D:\\Download\\fold'; this.report = { timestamp: new Date().toISOString(), folderPath: this.targetFolder, actions: [], filesProcessed: 0, foldersProcessed: 0, errors: [], warnings: [], structure: {}, subjects: [], sources: [] }; } async processAll() { console.log('ðŸŽ¯ DÃ©marrage du traitement du dossier externe...'); console.log(`ðŸ“ Dossier cible: ${this.targetFolder}`); try { // 1. VÃ©rifier l'existence du dossier await this.checkFolderExists(); // 2. Analyser la structure await this.analyzeStructure(); // 3. Identifier les sujets await this.identifySubjects(); // 4. Identifier les sources await this.identifySources(); // 5. Traiter les fichiers await this.processFiles(); // 6. Organiser le contenu await this.organizeContent(); // 7. GÃ©nÃ©rer la documentation await this.generateDocumentation(); // 8. CrÃ©er les rapports await this.createReports(); const duration = Date.now() - this.startTime; console.log(`âœ… Traitement terminÃ© en ${duration}ms`); } catch (error) { console.error('âŒ Erreur traitement:', error.message); this.report.errors.push(error.message); } } async checkFolderExists() { console.log('\nðŸ” 1. VÃ©rification de l\'existence du dossier...'); if (!fs.existsSync(this.targetFolder)) { throw new Error(`Le dossier ${this.targetFolder} n'existe pas`); } const stats = fs.statSync(this.targetFolder); if (!stats.isDirectory()) { throw new Error(`${this.targetFolder} n'est pas un dossier`); } console.log('âœ… Dossier trouvÃ© et accessible'); this.report.actions.push('Dossier vÃ©rifiÃ© et accessible'); } async analyzeStructure() { console.log('\nðŸ“ 2. Analyse de la structure...'); this.report.structure = await this.scanDirectory(this.targetFolder); console.log(`ðŸ“Š Structure analysÃ©e: ${Object.keys(this.report.structure).length} Ã©lÃ©ments`); this.report.actions.push('Structure analysÃ©e'); } async scanDirectory(dirPath, depth = 0) { const structure = { path: dirPath, name: path.basename(dirPath), type: 'directory', depth: depth, children: [], files: [], stats: null }; try { const items = fs.readdirSync(dirPath); for (const item of items) { const fullPath = path.join(dirPath, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { const childStructure = await this.scanDirectory(fullPath, depth + 1); structure.children.push(childStructure); } else { structure.files.push({ name: item, path: fullPath, size: stats.size, modified: stats.mtime, type: this.getFileType(item) }); } } structure.stats = { totalFiles: this.countFiles(structure), totalDirectories: this.countDirectories(structure), totalSize: this.calculateSize(structure) }; } catch (error) { console.log(`âš ï¸ Erreur lecture ${dirPath}: ${error.message}`); } return structure; } getFileType(filename) { const ext = path.extname(filename).toLowerCase(); const textExtensions = ['.txt', '.md', '.json', '.js', '.py', '.java', '.cpp', '.c', '.h', '.html', '.css', '.xml', '.yaml', '.yml']; const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico']; const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv']; const audioExtensions = ['.mp3', '.wav', '.flac', '.aac', '.ogg']; const archiveExtensions = ['.zip', '.rar', '.7z', '.tar', '.gz']; if (textExtensions.includes(ext)) return 'text'; if (imageExtensions.includes(ext)) return 'image'; if (videoExtensions.includes(ext)) return 'video'; if (audioExtensions.includes(ext)) return 'audio'; if (archiveExtensions.includes(ext)) return 'archive'; return 'unknown'; } countFiles(structure) { let count = structure.files.length; for (const child of structure.children) { count += this.countFiles(child); } return count; } countDirectories(structure) { let count = 1; // Include current directory for (const child of structure.children) { count += this.countDirectories(child); } return count; } calculateSize(structure) { let size = 0; for (const file of structure.files) { size += file.size; } for (const child of structure.children) { size += this.calculateSize(child); } return size; } async identifySubjects() { console.log('\nðŸŽ¯ 3. Identification des sujets...'); const subjects = new Set(); // Analyser les noms de fichiers et dossiers pour identifier les sujets this.extractSubjectsFromStructure(this.report.structure, subjects); this.report.subjects = Array.from(subjects); console.log(`ðŸ“Š Sujets identifiÃ©s: ${this.report.subjects.length}`); for (const subject of this.report.subjects) { console.log(` - ${subject}`); } this.report.actions.push(`IdentifiÃ© ${this.report.subjects.length} sujets`); } extractSubjectsFromStructure(structure, subjects) { // Analyser le nom du dossier/fichier const name = structure.name.toLowerCase(); const words = name.split(/[_\-\s\.]/); for (const word of words) { if (word.length > 2 && !this.isCommonWord(word)) { subjects.add(word); } } // Analyser les fichiers for (const file of structure.files) { const fileName = file.name.toLowerCase(); const fileWords = fileName.split(/[_\-\s\.]/); for (const word of fileWords) { if (word.length > 2 && !this.isCommonWord(word)) { subjects.add(word); } } } // Analyser les sous-dossiers for (const child of structure.children) { this.extractSubjectsFromStructure(child, subjects); } } isCommonWord(word) { const commonWords = [ 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'le', 'la', 'les', 'un', 'une', 'des', 'du', 'de', 'et', 'ou', 'mais', 'dans', 'sur', 'sous', 'avec', 'sans', 'pour', 'par', 'vers', 'depuis', 'pendant', 'file', 'folder', 'dir', 'doc', 'txt', 'pdf', 'img', 'pic', 'photo', 'image', 'video', 'audio', 'data', 'info', 'config', 'settings', 'temp', 'tmp', 'backup' ]; return commonWords.includes(word); } async identifySources() { console.log('\nðŸ“š 4. Identification des sources...'); const sources = new Set(); // Analyser les fichiers pour identifier les sources this.extractSourcesFromStructure(this.report.structure, sources); this.report.sources = Array.from(sources); console.log(`ðŸ“Š Sources identifiÃ©es: ${this.report.sources.length}`); for (const source of this.report.sources) { console.log(` - ${source}`); } this.report.actions.push(`IdentifiÃ© ${this.report.sources.length} sources`); } extractSourcesFromStructure(structure, sources) { // Analyser les fichiers texte pour identifier les sources for (const file of structure.files) { if (file.type === 'text') { try { const content = fs.readFileSync(file.path, 'utf8'); this.extractSourcesFromContent(content, sources); } catch (error) { // Ignorer les erreurs de lecture } } } // Analyser les sous-dossiers for (const child of structure.children) { this.extractSourcesFromStructure(child, sources); } } extractSourcesFromContent(content, sources) { // Chercher des patterns de sources (URLs, rÃ©fÃ©rences, etc.) const urlPattern = /https?:\/\/[^\s]+/g; const emailPattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g; const filePattern = /[a-zA-Z]:\\[^\s]+/g; const urls = content.match(urlPattern) || []; const emails = content.match(emailPattern) || []; const files = content.match(filePattern) || []; urls.forEach(url => sources.add(url)); emails.forEach(email => sources.add(email)); files.forEach(file => sources.add(file)); } async processFiles() { console.log('\nðŸ“„ 5. Traitement des fichiers...'); let processedCount = 0; await this.processStructureFiles(this.report.structure, processedCount); console.log(`âœ… ${processedCount} fichiers traitÃ©s`); this.report.actions.push(`TraitÃ© ${processedCount} fichiers`); } async processStructureFiles(structure, processedCount) { for (const file of structure.files) { try { await this.processSingleFile(file); processedCount++; } catch (error) { console.log(`âš ï¸ Erreur traitement ${file.name}: ${error.message}`); } } for (const child of structure.children) { await this.processStructureFiles(child, processedCount); } } async processSingleFile(file) { // Traitement spÃ©cifique selon le type de fichier switch (file.type) { case 'text': await this.processTextFile(file); break; case 'image': await this.processImageFile(file); break; case 'video': await this.processVideoFile(file); break; case 'audio': await this.processAudioFile(file); break; case 'archive': await this.processArchiveFile(file); break; default: await this.processUnknownFile(file); } } async processTextFile(file) { // Traitement des fichiers texte console.log(` ðŸ“„ Traitement texte: ${file.name}`); } async processImageFile(file) { // Traitement des fichiers image console.log(` ðŸ–¼ï¸ Traitement image: ${file.name}`); } async processVideoFile(file) { // Traitement des fichiers vidÃ©o console.log(` ðŸŽ¥ Traitement vidÃ©o: ${file.name}`); } async processAudioFile(file) { // Traitement des fichiers audio console.log(` ðŸŽµ Traitement audio: ${file.name}`); } async processArchiveFile(file) { // Traitement des archives console.log(` ðŸ“¦ Traitement archive: ${file.name}`); } async processUnknownFile(file) { // Traitement des fichiers inconnus console.log(` â“ Traitement inconnu: ${file.name}`); } async organizeContent() { console.log('\nðŸ“‚ 6. Organisation du contenu...'); // CrÃ©er une structure organisÃ©e basÃ©e sur les sujets identifiÃ©s const organizedPath = path.join(__dirname, '../organized-content'); if (!fs.existsSync(organizedPath)) { fs.mkdirSync(organizedPath, { recursive: true }); } // CrÃ©er des dossiers pour chaque sujet for (const subject of this.report.subjects) { const subjectPath = path.join(organizedPath, subject); if (!fs.existsSync(subjectPath)) { fs.mkdirSync(subjectPath, { recursive: true }); } } console.log('âœ… Contenu organisÃ©'); this.report.actions.push('Contenu organisÃ©'); } async generateDocumentation() { console.log('\nðŸ“š 7. GÃ©nÃ©ration de la documentation...'); const docsPath = path.join(__dirname, '../docs'); if (!fs.existsSync(docsPath)) { fs.mkdirSync(docsPath, { recursive: true }); } // GÃ©nÃ©rer la documentation de la structure const structureDoc = this.generateStructureDocumentation(); fs.writeFileSync(path.join(docsPath, 'structure.md'), structureDoc); // GÃ©nÃ©rer la documentation des sujets const subjectsDoc = this.generateSubjectsDocumentation(); fs.writeFileSync(path.join(docsPath, 'subjects.md'), subjectsDoc); // GÃ©nÃ©rer la documentation des sources const sourcesDoc = this.generateSourcesDocumentation(); fs.writeFileSync(path.join(docsPath, 'sources.md'), sourcesDoc); console.log('âœ… Documentation gÃ©nÃ©rÃ©e'); this.report.actions.push('Documentation gÃ©nÃ©rÃ©e'); } generateStructureDocumentation() { return `# ðŸ“ Documentation de la Structure ## ðŸ“… Date **${new Date().toLocaleString('fr-FR')}** ## ðŸ“‚ Dossier AnalysÃ© **${this.targetFolder}** ## ðŸ“Š Statistiques - **Fichiers**: ${this.report.structure.stats?.totalFiles || 0} - **Dossiers**: ${this.report.structure.stats?.totalDirectories || 0} - **Taille totale**: ${this.formatBytes(this.report.structure.stats?.totalSize || 0)} ## ðŸ—ï¸ Structure \`\`\` ${this.generateStructureTree(this.report.structure)} \`\`\` --- *GÃ©nÃ©rÃ© automatiquement par ExternalFolderProcessor* `; } generateStructureTree(structure, indent = '') { let tree = `${indent}ðŸ“ ${structure.name}\n`; for (const file of structure.files) { tree += `${indent} ðŸ“„ ${file.name} (${this.formatBytes(file.size)})\n`; } for (const child of structure.children) { tree += this.generateStructureTree(child, indent + ' '); } return tree; } generateSubjectsDocumentation() { return `# ðŸŽ¯ Documentation des Sujets ## ðŸ“… Date **${new Date().toLocaleString('fr-FR')}** ## ðŸ“Š Sujets IdentifiÃ©s **${this.report.subjects.length} sujets trouvÃ©s** ## ðŸ“‹ Liste des Sujets ${this.report.subjects.map(subject => `- **${subject}**`).join('\n')} ## ðŸ” Analyse Les sujets ont Ã©tÃ© extraits automatiquement des noms de fichiers et dossiers. --- *GÃ©nÃ©rÃ© automatiquement par ExternalFolderProcessor* `; } generateSourcesDocumentation() { return `# ðŸ“š Documentation des Sources ## ðŸ“… Date **${new Date().toLocaleString('fr-FR')}** ## ðŸ“Š Sources IdentifiÃ©es **${this.report.sources.length} sources trouvÃ©es** ## ðŸ“‹ Liste des Sources ${this.report.sources.map(source => `- **${source}**`).join('\n')} ## ðŸ” Analyse Les sources ont Ã©tÃ© extraites automatiquement du contenu des fichiers. --- *GÃ©nÃ©rÃ© automatiquement par ExternalFolderProcessor* `; } formatBytes(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; } async createReports() { console.log('\nðŸ“Š 8. CrÃ©ation des rapports...'); const reportsPath = path.join(__dirname, '../reports'); if (!fs.existsSync(reportsPath)) { fs.mkdirSync(reportsPath, { recursive: true }); } // Rapport JSON complet const jsonReport = JSON.stringify(this.report, null, 2); fs.writeFileSync(path.join(reportsPath, 'external-folder-analysis.json'), jsonReport); // Rapport Markdown const markdownReport = this.generateMarkdownReport(); fs.writeFileSync(path.join(reportsPath, 'external-folder-analysis.md'), markdownReport); console.log('âœ… Rapports crÃ©Ã©s'); this.report.actions.push('Rapports crÃ©Ã©s'); } generateMarkdownReport() { return `# ðŸš€ RAPPORT D'ANALYSE - DOSSIER EXTERNE ## ðŸ“… Date **${new Date().toLocaleString('fr-FR')}** ## ðŸ“ Dossier AnalysÃ© **${this.targetFolder}** ## ðŸ“Š Statistiques - **Fichiers traitÃ©s**: ${this.report.filesProcessed} - **Dossiers traitÃ©s**: ${this.report.foldersProcessed} - **Sujets identifiÃ©s**: ${this.report.subjects.length} - **Sources identifiÃ©es**: ${this.report.sources.length} - **Erreurs**: ${this.report.errors.length} - **Avertissements**: ${this.report.warnings.length} ## âœ… Actions EffectuÃ©es ${this.report.actions.map(action => `- âœ… ${action}`).join('\n')} ## ðŸŽ¯ Sujets IdentifiÃ©s ${this.report.subjects.map(subject => `- **${subject}**`).join('\n')} ## ðŸ“š Sources IdentifiÃ©es ${this.report.sources.map(source => `- **${source}**`).join('\n')} ## âŒ Erreurs ${this.report.errors.map(error => `- âŒ ${error}`).join('\n')} ## âš ï¸ Avertissements ${this.report.warnings.map(warning => `- âš ï¸ ${warning}`).join('\n')} ## ðŸŽ¯ Objectifs Atteints - âœ… Analyse de la structure - âœ… Identification des sujets - âœ… Identification des sources - âœ… Traitement des fichiers - âœ… Organisation du contenu - âœ… GÃ©nÃ©ration de documentation - âœ… CrÃ©ation de rapports --- **ðŸ“… GÃ©nÃ©rÃ©**: ${new Date().toISOString()} **ðŸŽ¯ Objectif**: Analyse complÃ¨te du dossier externe **âœ… Statut**: **TERMINÃ‰ AVEC SUCCÃˆS** `; } } // ExÃ©cution const processor = new ExternalFolderProcessor(); processor.processAll().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});