--- drivers\climate_monitor\device.js
+++ drivers\climate_monitor\device.js (patched)

--- original ---
'use strict';

const BaseHybridDevice = require('../../lib/BaseHybridDevice');

/**
 * ClimateMonitorDevice - Enhanced SDK3 Climate Monitor
 * 
 * Features:
 * - Temperature & Humidity sensing (clusters 1026, 1029)
 * - Multi-protocol battery detection (Zigbee/Tuya/Xiaomi)
 * - Time/Date synchronization to device screen
 * - Backlight control button
 * - Hybrid power support (AC/DC/Battery)
 * - SDK3 compliant: Numeric cluster IDs only
 * 
 * Supported Protocols:
 * - Standard Zigbee (TS0201, _TZ3000_* series)
 * - Tuya Custom (TS0601, _TZE200_* series, cluster 61184)
 * - Xiaomi/Aqara (lumi.* series)
 * 
 * Clusters:
 * - 0 (Basic): Device info, power source
 * - 1 (PowerConfiguration): Standard Zigbee battery
 * - 3 (Identify): Device identification
 * - 10 (Time): Standard Zigbee time sync
 * - 1026 (TemperatureMeasurement): Temperature sensor
 * - 1029 (RelativeHumidity): Humidity sensor
 * - 61184 (TuyaCustom/0xEF00): Tuya-specific features
 */
class ClimateMonitorDevice extends BaseHybridDevice {

  async onNodeInit() {
    this.log('ðŸŒ¡ï¸  ClimateMonitorDevice initializing (SDK3)...');
    
    // Initialize base (auto power detection + dynamic capabilities)
    await super.onNodeInit().catch(err => this.error(err));
    
    // Setup climate sensing (temperature & humidity)
    await this.setupClimateSensing();
    
    // Setup multi-protocol battery detection
    await this.setupMultiProtocolBattery();
    
    // Setup time synchronization
    await this.setupTimeSync();
    
    // Setup backlight button control
    await this.setupBacklightButton();
    
    this.log('âœ… ClimateMonitorDevice ready');
    this.log(`   Power source: ${this.powerType || 'unknown'}`);
    this.log(`   Model: ${this.getData().manufacturerName}`);
  }

  /**
   * Setup climate sensing capabilities (SDK3)
   * Uses numeric cluster IDs: 1026 (temperature), 1029 (humidity)
   */
  async setupClimateSensing() {
    this.log('ðŸŒ¡ï¸  Setting up climate sensing (SDK3)...');
    
    const endpoint = this.zclNode.endpoints[1];
    if (!endpoint) {
      this.log('âš ï¸  Endpoint 1 not available');
      return;
    }
    
    try {
      // Cluster 1026 (TemperatureMeasurement)
      if (this.hasCapability('measure_temperature') && endpoint.clusters[1026]) {
        this.registerCapability('measure_temperature', 1026, {
          get: 'measuredValue',
          report: 'measuredValue',
          reportParser: value => {
            const temp = value / 100; // Convert from centidegrees
            this.log('ðŸŒ¡ï¸  Temperature:', temp, 'Â°C');
            return temp;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 60,       // 1 minute
              maxInterval: 3600,     // 1 hour
              minChange: 10          // 0.1Â°C change
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Temperature sensor configured (cluster 1026)');
      }
      
      // Cluster 1029 (RelativeHumidity)
      if (this.hasCapability('measure_humidity') && endpoint.clusters[1029]) {
        this.registerCapability('measure_humidity', 1029, {
          get: 'measuredValue',
          report: 'measuredValue',
          reportParser: value => {
            const humidity = value / 100; // Convert from percentage * 100
            this.log('ðŸ’§ Humidity:', humidity, '%');
            return humidity;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 60,       // 1 minute
              maxInterval: 3600,     // 1 hour
              minChange: 100         // 1% change
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Humidity sensor configured (cluster 1029)');
      }
      
      this.log('âœ… Climate sensing configured');
    } catch (err) {
      this.error('Climate sensing setup failed:', err);
    }
  }

  /**
   * Setup multi-protocol battery detection (SDK3)
   * Supports: Standard Zigbee, Tuya Custom, Xiaomi/Aqara
   */
  async setupMultiProtocolBattery() {
    if (!this.hasCapability('measure_battery')) {
      return;
    }
    
    this.log('ðŸ”‹ Setting up multi-protocol battery detection...');
    
    const endpoint = this.zclNode.endpoints[1];
    const manufacturer = this.getData().manufacturerName || '';
    
    // Method 1: Standard Zigbee (Cluster 1 - PowerConfiguration)
    if (endpoint?.clusters[1]) {
      try {
        this.registerCapability('measure_battery', 1, {
          get: 'batteryPercentageRemaining',
          report: 'batteryPercentageRemaining',
          reportParser: value => {
            const battery = Math.round(value / 2); // Convert 0-200 to 0-100%
            this.log('ðŸ”‹ Battery (Zigbee):', battery, '%');
            return battery;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 300,      // 5 minutes
              maxInterval: 3600,     // 1 hour
              minChange: 2           // 1% change (raw value 2)
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Battery: Standard Zigbee (cluster 1)');
        this.batteryMethod = 'zigbee_standard';
        return;
      } catch (err) {
        this.log('Standard battery failed:', err.message);
      }
    }
    
    // Method 2: Tuya Custom (Cluster 61184 / 0xEF00, DP 101)
    if (endpoint?.clusters[61184]) {
      try {
        endpoint.clusters[61184].on('response', async (data) => {
          if (data.dp === 101) { // Battery DP
            const battery = data.data.readUInt8(0);
            await this.setCapabilityValue('measure_battery', battery).catch(this.error);
            this.log('ðŸ”‹ Battery (Tuya):', battery, '%');
          }
        });
        
        // Request initial battery status
        await endpoint.clusters[61184].command('dataQuery', { dp: 101 }).catch(() => {});
        
        this.log('âœ… Battery: Tuya Custom (cluster 61184, DP 101)');
        this.batteryMethod = 'tuya_custom';
        return;
      } catch (err) {
        this.log('Tuya battery failed:', err.message);
      }
    }
    
    // Method 3: Xiaomi/Aqara (Basic cluster attribute 0xFF01)
    if (manufacturer.startsWith('lumi.') && endpoint?.clusters[0]) {
      try {
        endpoint.clusters[0].on('attr.65281', async (value) => {
          if (value.batteryVoltage) {
            const battery = this.voltageToBattery(value.batteryVoltage);
            await this.setCapabilityValue('measure_battery', battery).catch(this.error);
            this.log('ðŸ”‹ Battery (Xiaomi):', battery, '%');
          }
        });
        
        this.log('âœ… Battery: Xiaomi/Aqara (attribute 0xFF01)');
        this.batteryMethod = 'xiaomi_custom';
        return;
      } catch (err) {
        this.log('Xiaomi battery failed:', err.message);
      }
    }
    
    this.log('âš ï¸  No battery detection method available');
    this.batteryMethod = 'none';
  }

  /**
   * Setup time synchronization to device screen
   * Supports both standard Zigbee Time cluster and Tuya custom
   */
  async setupTimeSync() {
    this.log('ðŸ• Setting up time synchronization...');
    
    const endpoint = this.zclNode.endpoints[1];
    
    // Detect supported time sync method
    this.timeSyncMethod = null;
    
    if (endpoint?.clusters[10]) {
      this.timeSyncMethod = 'zigbee_standard';
      this.log('âœ… Time sync: Standard Zigbee (cluster 10)');
    } else if (endpoint?.clusters[61184]) {
      this.timeSyncMethod = 'tuya_custom';
      this.log('âœ… Time sync: Tuya Custom (cluster 61184, DP 0x19)');
    } else {
      this.log('â„¹ï¸  Time sync not available on this device');
      return;
    }
    
    // Initial time sync
    await this.syncTimeToDevice();
    
    // Auto-sync every hour
    this.timeSyncInterval = setInterval(async () => {
      await this.syncTimeToDevice();
    }, 60 * 60 * 1000); // 1 hour
    
    this.log('âœ… Auto time sync configured (every 1 hour)');
  }

  /**
   * Sync current time/date to device screen
   */
  async syncTimeToDevice() {
    if (!this.timeSyncMethod) {
      return;
    }
    
    try {
      const endpoint = this.zclNode.endpoints[1];
      const now = new Date();
      
      if (this.timeSyncMethod === 'zigbee_standard') {
        // Method 1: Standard Zigbee Time Cluster (10)
        const zigbeeEpoch = Math.floor(Date.now() / 1000) - 946684800; // Seconds since 2000-01-01
        
        await endpoint.clusters[10].writeAttributes({
          time: zigbeeEpoch,
          timeStatus: {
            master: false,
            synchronized: true,
            masterZoneDst: false,
            superseding: false
          }
        });
        
        this.log('ðŸ• Time synced:', now.toLocaleString(), '(Zigbee standard)');
        
      } else if (this.timeSyncMethod === 'tuya_custom') {
        // Method 2: Tuya Custom Cluster (61184, DP 0x19)
        const timeData = {
          dp: 0x19, // Time sync DP
          datatype: 0x02, // String
          data: Buffer.from([
            now.getFullYear() - 2000,
            now.getMonth() + 1,
            now.getDate(),
            now.getHours(),
            now.getMinutes(),
            now.getSeconds()
          ])
        };
        
        await endpoint.clusters[61184].command('dataReport', timeData);
        
        this.log('ðŸ• Time synced:', now.toLocaleString(), '(Tuya custom)');
      }
    } catch (err) {
      this.error('Time sync failed:', err.message);
    }
  }

  /**
   * Setup backlight button control
   * Adds button.backlight capability for screen backlight control
   */
  async setupBacklightButton() {
    this.log('ðŸ’¡ Setting up backlight button...');
    
    const endpoint = this.zclNode.endpoints[1];
    
    // Detect supported backlight control method
    this.backlightMethod = null;
    
    if (endpoint?.clusters[61184]) {
      this.backlightMethod = 'tuya_custom';
      this.log('âœ… Backlight: Tuya Custom (cluster 61184, DP 0x0E)');
    } else if (endpoint?.clusters[3]) {
      this.backlightMethod = 'identify';
      this.log('âœ… Backlight: Identify cluster (cluster 3, flash)');
    } else {
      this.log('â„¹ï¸  Backlight control not available on this device');
      return;
    }
    
    // Add button.backlight capability if not present
    if (!this.hasCapability('button.backlight')) {
      await this.addCapability('button.backlight').catch(err => {
        this.log('Could not add backlight button:', err.message);
        return;
      });
    }
    
    // Register button listener
    if (this.hasCapability('button.backlight')) {
      this.registerCapabilityListener('button.backlight', async () => {
        await this.toggleBacklight();
      });
      this.log('âœ… Backlight button configured');
    }
  }

  /**
   * Toggle screen backlight
   */
  async toggleBacklight() {
    if (!this.backlightMethod) {
      return;
    }
    
    try {
      const endpoint = this.zclNode.endpoints[1];
      
      if (this.backlightMethod === 'tuya_custom') {
        // Method 1: Tuya Custom Cluster DP 0x0E
        await endpoint.clusters[61184].command('dataReport', {
          dp: 0x0E,
          datatype: 0x01, // Boolean
          data: Buffer.from([0x01]) // Toggle
        });
        
        this.log('ðŸ’¡ Backlight toggled (Tuya custom)');
        
      } else if (this.backlightMethod === 'identify') {
        // Method 2: Standard Identify cluster (flash briefly)
        const duration = this.getSetting('backlight_auto_off') || 10;
        
        await endpoint.clusters[3].identify({ identifyTime: duration });
        
        this.log(`ðŸ’¡ Screen flashed for ${duration}s (identify cluster)`);
      }
    } catch (err) {
      this.error('Backlight toggle failed:', err.message);
    }
  }

  /**
   * Convert battery voltage to percentage (for Xiaomi/Aqara)
   */
  voltageToBattery(voltage) {
    const batteryType = this.getSetting('battery_type') || 'CR2032';
    
    const voltageRanges = {
      'CR2032': { max: 3000, min: 2000 },
      'CR2450': { max: 3000, min: 2000 },
      'CR123A': { max: 3000, min: 2000 },
      'AA': { max: 1500, min: 900 },
      'AAA': { max: 1500, min: 900 }
    };
    
    const range = voltageRanges[batteryType] || voltageRanges['CR2032'];
    const percentage = Math.round(
      ((voltage - range.min) / (range.max - range.min)) * 100
    );
    
    return Math.max(0, Math.min(100, percentage));
  }

  async onDeleted() {
    this.log('ClimateMonitorDevice deleted');
    
    // Clear time sync interval
    if (this.timeSyncInterval) {
      clearInterval(this.timeSyncInterval);
    }
    
    await super.onDeleted().catch(err => this.error(err));
  }
}

module.exports = ClimateMonitorDevice;

--- patched ---
'use strict';

const BaseHybridDevice = require('../../lib/BaseHybridDevice');

/**
 * ClimateMonitorDevice - Enhanced SDK3 Climate Monitor
 * 
 * Features:
 * - Temperature & Humidity sensing (clusters 1026, 1029)
 * - Multi-protocol battery detection (Zigbee/Tuya/Xiaomi)
 * - Time/Date synchronization to device screen
 * - Backlight control button
 * - Hybrid power support (AC/DC/Battery)
 * - SDK3 compliant: Numeric cluster IDs only
 * 
 * Supported Protocols:
 * - Standard Zigbee (TS0201, _TZ3000_* series)
 * - Tuya Custom (TS0601, _TZE200_* series, cluster 61184)
 * - Xiaomi/Aqara (lumi.* series)
 * 
 * Clusters:
 * - 0 (Basic): Device info, power source
 * - 1 (PowerConfiguration): Standard Zigbee battery
 * - 3 (Identify): Device identification
 * - 10 (Time): Standard Zigbee time sync
 * - 1026 (TemperatureMeasurement): Temperature sensor
 * - 1029 (RelativeHumidity): Humidity sensor
 * - 61184 (TuyaCustom/0xEF00): Tuya-specific features
 */
class ClimateMonitorDevice extends BaseHybridDevice {

  async onNodeInit() {
    this.log('ðŸŒ¡ï¸  ClimateMonitorDevice initializing (SDK3)...');
    
    // Initialize base (auto power detection + dynamic capabilities)
    await super.onNodeInit().catch(err => this.error(err));
    
    // Setup climate sensing (temperature & humidity)
    await this.setupClimateSensing();
    
    // Setup multi-protocol battery detection
    await this.setupMultiProtocolBattery();
    
    // Setup time synchronization
    await this.setupTimeSync();
    
    // Setup backlight button control
    await this.setupBacklightButton();
    
    this.log('âœ… ClimateMonitorDevice ready');
    this.log(`   Power source: ${this.powerType || 'unknown'}`);
    this.log(`   Model: ${this.getData().manufacturerName}`);
  }

  /**
   * Setup climate sensing capabilities (SDK3)
   * Uses numeric cluster IDs: 1026 (temperature), 1029 (humidity)
   */
  async setupClimateSensing() {
    this.log('ðŸŒ¡ï¸  Setting up climate sensing (SDK3)...');
    
    const endpoint = this.zclNode.endpoints[1];
    if (!endpoint) {
      this.log('âš ï¸  Endpoint 1 not available');
      return;
    }
    
    try {
      // Cluster 1026 (TemperatureMeasurement)
      if (this.hasCapability('measure_temperature') && endpoint.clusters[1026]) {
        /* REFACTOR: registerCapability deprecated with cluster spec.
   Original: this.registerCapability('measure_temperature', 1026,
   Replace with SDK3 pattern - see ZigbeeDevice docs
   Capability: 'measure_temperature', Cluster: 1026
*/
// this.registerCapability('measure_temperature', 1026, {
          get: 'measuredValue',
          report: 'measuredValue',
          reportParser: value => {
            const temp = value / 100; // Convert from centidegrees
            this.log('ðŸŒ¡ï¸  Temperature:', temp, 'Â°C');
            return temp;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 60,       // 1 minute
              maxInterval: 3600,     // 1 hour
              minChange: 10          // 0.1Â°C change
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Temperature sensor configured (cluster 1026)');
      }
      
      // Cluster 1029 (RelativeHumidity)
      if (this.hasCapability('measure_humidity') && endpoint.clusters[1029]) {
        /* REFACTOR: registerCapability deprecated with cluster spec.
   Original: this.registerCapability('measure_humidity', 1029,
   Replace with SDK3 pattern - see ZigbeeDevice docs
   Capability: 'measure_humidity', Cluster: 1029
*/
// this.registerCapability('measure_humidity', 1029, {
          get: 'measuredValue',
          report: 'measuredValue',
          reportParser: value => {
            const humidity = value / 100; // Convert from percentage * 100
            this.log('ðŸ’§ Humidity:', humidity, '%');
            return humidity;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 60,       // 1 minute
              maxInterval: 3600,     // 1 hour
              minChange: 100         // 1% change
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Humidity sensor configured (cluster 1029)');
      }
      
      this.log('âœ… Climate sensing configured');
    } catch (err) {
      this.error('Climate sensing setup failed:', err);
    }
  }

  /**
   * Setup multi-protocol battery detection (SDK3)
   * Supports: Standard Zigbee, Tuya Custom, Xiaomi/Aqara
   */
  async setupMultiProtocolBattery() {
    if (!this.hasCapability('measure_battery')) {
      return;
    }
    
    this.log('ðŸ”‹ Setting up multi-protocol battery detection...');
    
    const endpoint = this.zclNode.endpoints[1];
    const manufacturer = this.getData().manufacturerName || '';
    
    // Method 1: Standard Zigbee (Cluster 1 - PowerConfiguration)
    if (endpoint?.clusters[1]) {
      try {
        /* REFACTOR: registerCapability deprecated with cluster spec.
   Original: this.registerCapability('measure_battery', 1,
   Replace with SDK3 pattern - see ZigbeeDevice docs
   Capability: 'measure_battery', Cluster: 1
*/
// this.registerCapability('measure_battery', 1, {
          get: 'batteryPercentageRemaining',
          report: 'batteryPercentageRemaining',
          reportParser: value => {
            const battery = Math.round(value / 2); // Convert 0-200 to 0-100%
            this.log('ðŸ”‹ Battery (Zigbee):', battery, '%');
            return battery;
          },
          reportOpts: {
            configureAttributeReporting: {
              minInterval: 300,      // 5 minutes
              maxInterval: 3600,     // 1 hour
              minChange: 2           // 1% change (raw value 2)
            }
          },
          getOpts: {
            getOnStart: true
          }
        });
        this.log('âœ… Battery: Standard Zigbee (cluster 1)');
        this.batteryMethod = 'zigbee_standard';
        return;
      } catch (err) {
        this.log('Standard battery failed:', err.message);
      }
    }
    
    // Method 2: Tuya Custom (Cluster 61184 / 0xEF00, DP 101)
    if (endpoint?.clusters[61184]) {
      try {
        endpoint.clusters[61184].on('response', async (data) => {
          if (data.dp === 101) { // Battery DP
            const battery = data.data.readUInt8(0);
            await this.setCapabilityValue('measure_battery', battery).catch(this.error);
            this.log('ðŸ”‹ Battery (Tuya):', battery, '%');
          }
        });
        
        // Request initial battery status
        await endpoint.clusters[61184].command('dataQuery', { dp: 101 }).catch(() => {});
        
        this.log('âœ… Battery: Tuya Custom (cluster 61184, DP 101)');
        this.batteryMethod = 'tuya_custom';
        return;
      } catch (err) {
        this.log('Tuya battery failed:', err.message);
      }
    }
    
    // Method 3: Xiaomi/Aqara (Basic cluster attribute 0xFF01)
    if (manufacturer.startsWith('lumi.') && endpoint?.clusters[0]) {
      try {
        endpoint.clusters[0].on('attr.65281', async (value) => {
          if (value.batteryVoltage) {
            const battery = this.voltageToBattery(value.batteryVoltage);
            await this.setCapabilityValue('measure_battery', battery).catch(this.error);
            this.log('ðŸ”‹ Battery (Xiaomi):', battery, '%');
          }
        });
        
        this.log('âœ… Battery: Xiaomi/Aqara (attribute 0xFF01)');
        this.batteryMethod = 'xiaomi_custom';
        return;
      } catch (err) {
        this.log('Xiaomi battery failed:', err.message);
      }
    }
    
    this.log('âš ï¸  No battery detection method available');
    this.batteryMethod = 'none';
  }

  /**
   * Setup time synchronization to device screen
   * Supports both standard Zigbee Time cluster and Tuya custom
   */
  async setupTimeSync() {
    this.log('ðŸ• Setting up time synchronization...');
    
    const endpoint = this.zclNode.endpoints[1];
    
    // Detect supported time sync method
    this.timeSyncMethod = null;
    
    if (endpoint?.clusters[10]) {
      this.timeSyncMethod = 'zigbee_standard';
      this.log('âœ… Time sync: Standard Zigbee (cluster 10)');
    } else if (endpoint?.clusters[61184]) {
      this.timeSyncMethod = 'tuya_custom';
      this.log('âœ… Time sync: Tuya Custom (cluster 61184, DP 0x19)');
    } else {
      this.log('â„¹ï¸  Time sync not available on this device');
      return;
    }
    
    // Initial time sync
    await this.syncTimeToDevice();
    
    // Auto-sync every hour
    this.timeSyncInterval = setInterval(async () => {
      await this.syncTimeToDevice();
    }, 60 * 60 * 1000); // 1 hour
    
    this.log('âœ… Auto time sync configured (every 1 hour)');
  }

  /**
   * Sync current time/date to device screen
   */
  async syncTimeToDevice() {
    if (!this.timeSyncMethod) {
      return;
    }
    
    try {
      const endpoint = this.zclNode.endpoints[1];
      const now = new Date();
      
      if (this.timeSyncMethod === 'zigbee_standard') {
        // Method 1: Standard Zigbee Time Cluster (10)
        const zigbeeEpoch = Math.floor(Date.now() / 1000) - 946684800; // Seconds since 2000-01-01
        
        await endpoint.clusters[10].writeAttributes({
          time: zigbeeEpoch,
          timeStatus: {
            master: false,
            synchronized: true,
            masterZoneDst: false,
            superseding: false
          }
        });
        
        this.log('ðŸ• Time synced:', now.toLocaleString(), '(Zigbee standard)');
        
      } else if (this.timeSyncMethod === 'tuya_custom') {
        // Method 2: Tuya Custom Cluster (61184, DP 0x19)
        const timeData = {
          dp: 0x19, // Time sync DP
          datatype: 0x02, // String
          data: Buffer.from([
            now.getFullYear() - 2000,
            now.getMonth() + 1,
            now.getDate(),
            now.getHours(),
            now.getMinutes(),
            now.getSeconds()
          ])
        };
        
        await endpoint.clusters[61184].command('dataReport', timeData);
        
        this.log('ðŸ• Time synced:', now.toLocaleString(), '(Tuya custom)');
      }
    } catch (err) {
      this.error('Time sync failed:', err.message);
    }
  }

  /**
   * Setup backlight button control
   * Adds button.backlight capability for screen backlight control
   */
  async setupBacklightButton() {
    this.log('ðŸ’¡ Setting up backlight button...');
    
    const endpoint = this.zclNode.endpoints[1];
    
    // Detect supported backlight control method
    this.backlightMethod = null;
    
    if (endpoint?.clusters[61184]) {
      this.backlightMethod = 'tuya_custom';
      this.log('âœ… Backlight: Tuya Custom (cluster 61184, DP 0x0E)');
    } else if (endpoint?.clusters[3]) {
      this.backlightMethod = 'identify';
      this.log('âœ… Backlight: Identify cluster (cluster 3, flash)');
    } else {
      this.log('â„¹ï¸  Backlight control not available on this device');
      return;
    }
    
    // Add button.backlight capability if not present
    if (!this.hasCapability('button.backlight')) {
      await this.addCapability('button.backlight').catch(err => {
        this.log('Could not add backlight button:', err.message);
        return;
      });
    }
    
    // Register button listener
    if (this.hasCapability('button.backlight')) {
      this.registerCapabilityListener('button.backlight', async () => {
        await this.toggleBacklight();
      });
      this.log('âœ… Backlight button configured');
    }
  }

  /**
   * Toggle screen backlight
   */
  async toggleBacklight() {
    if (!this.backlightMethod) {
      return;
    }
    
    try {
      const endpoint = this.zclNode.endpoints[1];
      
      if (this.backlightMethod === 'tuya_custom') {
        // Method 1: Tuya Custom Cluster DP 0x0E
        await endpoint.clusters[61184].command('dataReport', {
          dp: 0x0E,
          datatype: 0x01, // Boolean
          data: Buffer.from([0x01]) // Toggle
        });
        
        this.log('ðŸ’¡ Backlight toggled (Tuya custom)');
        
      } else if (this.backlightMethod === 'identify') {
        // Method 2: Standard Identify cluster (flash briefly)
        const duration = this.getSetting('backlight_auto_off') || 10;
        
        await endpoint.clusters[3].identify({ identifyTime: duration });
        
        this.log(`ðŸ’¡ Screen flashed for ${duration}s (identify cluster)`);
      }
    } catch (err) {
      this.error('Backlight toggle failed:', err.message);
    }
  }

  /**
   * Convert battery voltage to percentage (for Xiaomi/Aqara)
   */
  voltageToBattery(voltage) {
    const batteryType = this.getSetting('battery_type') || 'CR2032';
    
    const voltageRanges = {
      'CR2032': { max: 3000, min: 2000 },
      'CR2450': { max: 3000, min: 2000 },
      'CR123A': { max: 3000, min: 2000 },
      'AA': { max: 1500, min: 900 },
      'AAA': { max: 1500, min: 900 }
    };
    
    const range = voltageRanges[batteryType] || voltageRanges['CR2032'];
    const percentage = Math.round(
      ((voltage - range.min) / (range.max - range.min)) * 100
    );
    
    return Math.max(0, Math.min(100, percentage));
  }

  async onDeleted() {
    this.log('ClimateMonitorDevice deleted');
    
    // Clear time sync interval
    if (this.timeSyncInterval) {
      clearInterval(this.timeSyncInterval);
    }
    
    await super.onDeleted().catch(err => this.error(err));
  }
}

module.exports = ClimateMonitorDevice;
