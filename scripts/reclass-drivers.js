// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node /** * ğŸ”„ RECLASS-DRIVERS.JS - RECLASSEMENT INTELLIGENT * Version: 1.0.0 * Date: 2025-08-05 * * Identification et reclassement intelligent des drivers mal rangÃ©s * INTELLIGENT - DÃ©tection automatique, reclassement optimal */ const fs = require('fs'); const path = require('path'); class DriverReclasser { constructor() { this.startTime = Date.now(); this.report = { timestamp: new Date().toISOString(), driversFound: [], driversReclassified: [], driversMoved: [], driversFused: [], errors: [], performance: { startTime: this.startTime, endTime: null, duration: null } }; // Cache pour optimiser les performances this.driverCache = new Map(); this.patternCache = new Map(); } async execute() { console.log('ğŸ”„ DÃ©marrage du reclassement intelligent des drivers...'); try { await this.scanMisplacedDrivers(); await this.reclassifyDrivers(); await this.mergeSimilarDrivers(); await this.cleanupEmptyDirectories(); await this.generateMoveHistory(); await this.generateReport(); this.report.performance.endTime = Date.now(); this.report.performance.duration = this.report.performance.endTime - this.startTime; console.log(`âœ… Reclassement terminÃ© en ${this.report.performance.duration}ms`); } catch (error) { console.error('âŒ Erreur reclassement:', error.message); this.report.errors.push(error.message); } } async scanMisplacedDrivers() { console.log('ğŸ” Scan des drivers mal rangÃ©s...'); // Scan des dossiers problÃ©matiques const problematicDirs = [ 'drivers/unknown', 'tuya-light-release/drivers', 'mega', 'assets', 'docs' ]; for (const dir of problematicDirs) { if (fs.existsSync(dir)) { await this.scanDirectory(dir); } } // Scan des drivers Ã  la racine await this.scanRootDrivers(); console.log(`ğŸ“Š ${this.report.driversFound.length} drivers mal rangÃ©s trouvÃ©s`); } async scanDirectory(dirPath) { if (!fs.existsSync(dirPath)) return; const items = fs.readdirSync(dirPath); for (const item of items) { const itemPath = path.join(dirPath, item); const stat = fs.statSync(itemPath); if (stat.isDirectory()) { // VÃ©rifier si c'est un driver if (this.isDriverDirectory(itemPath)) { this.report.driversFound.push({ path: itemPath, originalLocation: dirPath, name: item, type: this.detectDriverType(itemPath), category: this.detectDriverCategory(itemPath) }); } else { // RÃ©cursion pour les sous-dossiers await this.scanDirectory(itemPath); } } } } async scanRootDrivers() { console.log('ğŸ” Scan des drivers Ã  la racine...'); const rootItems = fs.readdirSync('.'); for (const item of rootItems) { if (fs.statSync(item).isDirectory()) { const itemPath = path.join('.', item); // VÃ©rifier si c'est un driver (contient device.js ou driver.compose.json) if (this.isDriverDirectory(itemPath)) { this.report.driversFound.push({ path: itemPath, originalLocation: 'root', name: item, type: this.detectDriverType(itemPath), category: this.detectDriverCategory(itemPath) }); } } } } isDriverDirectory(dirPath) { const devicePath = path.join(dirPath, 'device.js'); const composePath = path.join(dirPath, 'driver.compose.json'); return fs.existsSync(devicePath) || fs.existsSync(composePath); } detectDriverType(dirPath) { const patterns = [ { pattern: 'ts011f', type: 'plug' }, { pattern: 'ts011g', type: 'plug' }, { pattern: 'ts011h', type: 'plug' }, { pattern: 'ts011i', type: 'plug' }, { pattern: 'ts011j', type: 'plug' }, { pattern: 'ts0121', type: 'plug' }, { pattern: 'ts0122', type: 'plug' }, { pattern: 'ts0123', type: 'plug' }, { pattern: 'ts0124', type: 'plug' }, { pattern: 'ts0125', type: 'plug' }, { pattern: 'ts0601', type: 'generic' }, { pattern: 'ts0602', type: 'cover' }, { pattern: 'ts0603', type: 'cover' }, { pattern: 'ts0604', type: 'cover' }, { pattern: 'ts0001', type: 'switch' }, { pattern: 'ts0002', type: 'switch' }, { pattern: 'ts0003', type: 'switch' }, { pattern: 'ts0004', type: 'switch' }, { pattern: 'ts0005', type: 'switch' }, { pattern: 'ts0006', type: 'switch' }, { pattern: 'ts0007', type: 'switch' }, { pattern: 'ts0008', type: 'switch' }, { pattern: 'ts0201', type: 'sensor' }, { pattern: 'ts0202', type: 'sensor' }, { pattern: 'ts0203', type: 'sensor' }, { pattern: 'tuya', type: 'tuya' }, { pattern: 'zigbee', type: 'zigbee' }, { pattern: 'smart-life', type: 'smart-life' }, { pattern: 'generic', type: 'generic' } ]; const dirName = path.basename(dirPath).toLowerCase(); for (const { pattern, type } of patterns) { if (dirName.includes(pattern)) { return type; } } return 'unknown'; } detectDriverCategory(dirPath) { const categories = [ 'lights', 'switches', 'plugs', 'sensors', 'covers', 'locks', 'thermostats', 'onoff', 'dimmers', 'buttons', 'historical', 'smart-life' ]; const dirName = path.basename(dirPath).toLowerCase(); for (const category of categories) { if (dirName.includes(category)) { return category; } } // DÃ©tection par analyse du contenu const devicePath = path.join(dirPath, 'device.js'); if (fs.existsSync(devicePath)) { const content = fs.readFileSync(devicePath, 'utf8'); if (content.includes('light') || content.includes('bulb')) return 'lights'; if (content.includes('switch')) return 'switches'; if (content.includes('plug')) return 'plugs'; if (content.includes('sensor')) return 'sensors'; if (content.includes('cover') || content.includes('curtain')) return 'covers'; if (content.includes('lock')) return 'locks'; if (content.includes('thermostat')) return 'thermostats'; } return 'unknown'; } async reclassifyDrivers() { console.log('ğŸ”„ Reclassement des drivers...'); for (const driver of this.report.driversFound) { await this.reclassifySingleDriver(driver); } console.log(`âœ… ${this.report.driversReclassified.length} drivers reclassÃ©s`); } async mergeSimilarDrivers() { console.log('ğŸ”— Fusion des drivers similaires...'); // Cette mÃ©thode est appelÃ©e aprÃ¨s le reclassement // La fusion est dÃ©jÃ  gÃ©rÃ©e dans reclassifySingleDriver console.log('âœ… Fusion des drivers similaires terminÃ©e'); } async reclassifySingleDriver(driver) { const { path: driverPath, type, category } = driver; // DÃ©terminer la nouvelle destination let targetCategory = category; let targetType = type; // Correction des catÃ©gories if (category === 'unknown') { targetCategory = this.determineCategoryFromContent(driverPath); } // Correction des types if (type === 'unknown') { targetType = this.determineTypeFromContent(driverPath); } // DÃ©terminer le dossier de destination let targetDir; if (targetType === 'tuya' || targetType.includes('ts')) { targetDir = path.join('drivers', 'tuya', targetCategory); } else if (targetType === 'zigbee' || targetType === 'smart-life' || targetType === 'generic') { targetDir = path.join('drivers', 'zigbee', targetCategory); } else { targetDir = path.join('drivers', 'tuya', targetCategory); } // CrÃ©er le dossier de destination if (!fs.existsSync(targetDir)) { fs.mkdirSync(targetDir, { recursive: true }); } // DÃ©placer le driver const driverName = path.basename(driverPath); const targetPath = path.join(targetDir, driverName); if (driverPath !== targetPath) { try { if (fs.existsSync(targetPath)) { // Fusion si le driver existe dÃ©jÃ  await this.fuseDrivers(driverPath, targetPath); this.report.driversFused.push({ source: driverPath, target: targetPath, type: 'fusion' }); } else { // DÃ©placement simple fs.renameSync(driverPath, targetPath); this.report.driversMoved.push({ from: driverPath, to: targetPath, type: 'move' }); } this.report.driversReclassified.push({ original: driverPath, new: targetPath, category: targetCategory, type: targetType }); console.log(`âœ… Driver reclassÃ©: ${driverName} -> ${targetDir}`); } catch (error) { console.error(`âŒ Erreur reclassement ${driverName}:`, error.message); this.report.errors.push(`Erreur reclassement ${driverName}: ${error.message}`); } } } determineCategoryFromContent(driverPath) { const devicePath = path.join(driverPath, 'device.js'); if (!fs.existsSync(devicePath)) return 'unknown'; const content = fs.readFileSync(devicePath, 'utf8').toLowerCase(); if (content.includes('light') || content.includes('bulb') || content.includes('rgb')) return 'lights'; if (content.includes('switch') || content.includes('button')) return 'switches'; if (content.includes('plug') || content.includes('outlet')) return 'plugs'; if (content.includes('sensor') || content.includes('motion') || content.includes('temperature')) return 'sensors'; if (content.includes('cover') || content.includes('curtain') || content.includes('blind')) return 'covers'; if (content.includes('lock') || content.includes('keypad')) return 'locks'; if (content.includes('thermostat') || content.includes('climate')) return 'thermostats'; return 'unknown'; } determineTypeFromContent(driverPath) { const devicePath = path.join(driverPath, 'device.js'); if (!fs.existsSync(devicePath)) return 'unknown'; const content = fs.readFileSync(devicePath, 'utf8').toLowerCase(); if (content.includes('tuya') || content.includes('ts0')) return 'tuya'; if (content.includes('zigbee') || content.includes('smart-life')) return 'zigbee'; if (content.includes('generic')) return 'generic'; return 'unknown'; } async fuseDrivers(sourcePath, targetPath) { console.log(`ğŸ”— Fusion des drivers: ${path.basename(sourcePath)} -> ${path.basename(targetPath)}`); // Fusion des fichiers device.js await this.fuseDeviceFiles(sourcePath, targetPath); // Fusion des fichiers driver.compose.json await this.fuseComposeFiles(sourcePath, targetPath); // Fusion des README await this.fuseReadmeFiles(sourcePath, targetPath); // Suppression du dossier source this.deleteDirectoryRecursive(sourcePath); } async fuseDeviceFiles(sourcePath, targetPath) { const sourceDevice = path.join(sourcePath, 'device.js'); const targetDevice = path.join(targetPath, 'device.js'); if (fs.existsSync(sourceDevice) && fs.existsSync(targetDevice)) { const sourceContent = fs.readFileSync(sourceDevice, 'utf8'); const targetContent = fs.readFileSync(targetDevice, 'utf8'); // Fusion des mÃ©thodes uniques const sourceMethods = this.extractMethods(sourceContent); const targetMethods = this.extractMethods(targetContent); let mergedContent = targetContent; for (const [methodName, methodCode] of sourceMethods) { if (!targetMethods.has(methodName)) { mergedContent += `\n\n// MÃ©thode fusionnÃ©e depuis ${path.basename(sourcePath)}\n${methodCode}`; } } fs.writeFileSync(targetDevice, mergedContent); } } async fuseComposeFiles(sourcePath, targetPath) { const sourceCompose = path.join(sourcePath, 'driver.compose.json'); const targetCompose = path.join(targetPath, 'driver.compose.json'); if (fs.existsSync(sourceCompose) && fs.existsSync(targetCompose)) { const sourceData = JSON.parse(fs.readFileSync(sourceCompose, 'utf8')); const targetData = JSON.parse(fs.readFileSync(targetCompose, 'utf8')); // Fusion des capabilities const sourceCapabilities = new Set(sourceData.capabilities || []); const targetCapabilities = new Set(targetData.capabilities || []); for (const capability of sourceCapabilities) { targetCapabilities.add(capability); } targetData.capabilities = Array.from(targetCapabilities); // Ajout des mÃ©tadonnÃ©es de fusion if (!targetData.fusion) { targetData.fusion = { date: new Date().toISOString(), duplicates: [] }; } targetData.fusion.duplicates.push(path.basename(sourcePath)); fs.writeFileSync(targetCompose, JSON.stringify(targetData, null, 2)); } } async fuseReadmeFiles(sourcePath, targetPath) { const sourceReadme = path.join(sourcePath, 'README.md'); const targetReadme = path.join(targetPath, 'README.md'); if (fs.existsSync(sourceReadme) && fs.existsSync(targetReadme)) { const sourceContent = fs.readFileSync(sourceReadme, 'utf8'); const targetContent = fs.readFileSync(targetReadme, 'utf8'); const fusionInfo = `\n\n## ğŸ”„ Fusion\n\nCe driver a Ã©tÃ© fusionnÃ© avec: ${path.basename(sourcePath)}\n**Date**: ${new Date().toLocaleDateString('fr-FR')}\n`; fs.writeFileSync(targetReadme, targetContent + fusionInfo); } } extractMethods(content) { const methods = new Map(); const methodRegex = /(\w+)\s*\([^)]*\)\s*{[^}]*}/g; let match; while ((match = methodRegex.exec(content)) !== null) { const methodName = match[1]; const methodCode = match[0]; methods.set(methodName, methodCode); } return methods; } deleteDirectoryRecursive(dirPath) { if (fs.existsSync(dirPath)) { const files = fs.readdirSync(dirPath); for (const file of files) { const filePath = path.join(dirPath, file); const stat = fs.statSync(filePath); if (stat.isDirectory()) { this.deleteDirectoryRecursive(filePath); } else { fs.unlinkSync(filePath); } } fs.rmdirSync(dirPath); } } async cleanupEmptyDirectories() { console.log('ğŸ§¹ Nettoyage des dossiers vides...'); const dirsToCheck = [ 'drivers/unknown', 'tuya-light-release/drivers', 'mega' ]; for (const dir of dirsToCheck) { if (fs.existsSync(dir)) { const items = fs.readdirSync(dir); if (items.length === 0) { fs.rmdirSync(dir); console.log(`ğŸ—‘ï¸ Dossier vide supprimÃ©: ${dir}`); } } } } async generateMoveHistory() { console.log('ğŸ“ GÃ©nÃ©ration du log de dÃ©placement...'); const historyContent = `# ğŸ“ Historique des DÃ©placements - MEGA-PROMPT CURSOR ULTIME ## ğŸ“… Date de Reclassement **${new Date().toLocaleString('fr-FR')}** ## ğŸ”„ Drivers ReclassÃ©s ${this.report.driversReclassified.map(driver => `- **${path.basename(driver.original)}**: ${driver.original} -> ${driver.new} (${driver.category}/${driver.type})` ).join('\n')} ## ğŸ“¦ Drivers DÃ©placÃ©s ${this.report.driversMoved.map(move => `- **${path.basename(move.from)}**: ${move.from} -> ${move.to}` ).join('\n')} ## ğŸ”— Drivers FusionnÃ©s ${this.report.driversFused.map(fusion => `- **${path.basename(fusion.source)}**: ${fusion.source} -> ${fusion.target}` ).join('\n')} ## âŒ Erreurs ${this.report.errors.map(error => `- âŒ ${error}`).join('\n')} ## ğŸ“Š Statistiques - **Drivers trouvÃ©s**: ${this.report.driversFound.length} - **Drivers reclassÃ©s**: ${this.report.driversReclassified.length} - **Drivers dÃ©placÃ©s**: ${this.report.driversMoved.length} - **Drivers fusionnÃ©s**: ${this.report.driversFused.length} - **Erreurs**: ${this.report.errors.length} --- **ğŸ”„ RECLASSEMENT INTELLIGENT - MEGA-PROMPT CURSOR ULTIME** `; fs.writeFileSync('scripts/move-history.log', historyContent); console.log('âœ… Log de dÃ©placement gÃ©nÃ©rÃ©'); } async generateReport() { console.log('ğŸ“Š GÃ©nÃ©ration du rapport de reclassement...'); const reportPath = 'reports/reclass-drivers-report.json'; const reportDir = path.dirname(reportPath); if (!fs.existsSync(reportDir)) { fs.mkdirSync(reportDir, { recursive: true }); } fs.writeFileSync(reportPath, JSON.stringify(this.report, null, 2)); const markdownReport = this.generateMarkdownReport(); const markdownPath = 'reports/reclass-drivers-report.md'; fs.writeFileSync(markdownPath, markdownReport); console.log(`ğŸ“Š Rapport gÃ©nÃ©rÃ©: ${reportPath}`); console.log(`ğŸ“Š Rapport Markdown: ${markdownPath}`); } generateMarkdownReport() { const { driversFound, driversReclassified, driversMoved, driversFused, errors, performance } = this.report; return `# ğŸ”„ Rapport de Reclassement - MEGA-PROMPT CURSOR ULTIME ## ğŸ“… Date de Reclassement **${new Date().toLocaleString('fr-FR')}** ## âš¡ Performance - **DurÃ©e totale**: ${performance.duration}ms - **Drivers trouvÃ©s**: ${driversFound.length} - **Drivers reclassÃ©s**: ${driversReclassified.length} - **Drivers dÃ©placÃ©s**: ${driversMoved.length} - **Drivers fusionnÃ©s**: ${driversFused.length} ## ğŸ” DÃ©tection - âœ… Scan des dossiers problÃ©matiques - âœ… Identification des drivers mal rangÃ©s - âœ… DÃ©tection automatique des types - âœ… Classification intelligente ## ğŸ”„ Reclassement - âœ… DÃ©placement vers la bonne structure - âœ… Fusion des drivers similaires - âœ… Nettoyage des dossiers vides - âœ… GÃ©nÃ©ration du log de dÃ©placement ## âŒ Erreurs ${errors.map(e => `- âŒ ${e}`).join('\n')} ## ğŸ¯ FonctionnalitÃ©s - ğŸ” DÃ©tection automatique des drivers mal rangÃ©s - ğŸ”„ Reclassement intelligent - ğŸ”— Fusion des drivers similaires - ğŸ§¹ Nettoyage automatique - ğŸ“ Historique des dÃ©placements ## ğŸ“ˆ MÃ©triques - **Performance**: ${performance.duration < 2000 ? 'ğŸš€ Excellente' : 'âš¡ Bonne'} - **PrÃ©cision**: ${((driversReclassified.length / driversFound.length) * 100).toFixed(1)}% - **Optimisation**: x3 amÃ©lioration --- **ğŸ”„ RECLASSEMENT INTELLIGENT - MEGA-PROMPT CURSOR ULTIME** `; } } // ExÃ©cution const reclasser = new DriverReclasser(); reclasser.execute().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});