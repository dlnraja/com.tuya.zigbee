#!/usr/bin/env node
'use strict';

/**
 * ULTIMATE PROJECT ORGANIZER
 * Organisation complète et intelligente de TOUS les fichiers JS et structure projet
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.join(__dirname, '..');

class UltimateProjectOrganizer {
  constructor() {
    this.organized = {
      scripts: [],
      utils: [],
      moved: [],
      created: []
    };
    
    this.structure = {
      'scripts/core': 'Scripts essentiels core',
      'scripts/automation': 'Scripts automation',
      'scripts/validation': 'Scripts validation',
      'scripts/enrichment': 'Scripts enrichissement',
      'scripts/organization': 'Scripts organisation',
      'scripts/maintenance': 'Scripts maintenance',
      'scripts/deployment': 'Scripts déploiement',
      'scripts/monitoring': 'Scripts monitoring',
      'scripts/tools': 'Outils divers',
      'utils/helpers': 'Helpers utilitaires',
      'utils/validators': 'Validateurs',
      'utils/parsers': 'Parseurs'
    };
  }

  log(msg, icon = '📁') {
    console.log(`${icon} ${msg}`);
  }

  // Créer structure
  createStructure() {
    this.log('Création structure organisée...', '🏗️');
    
    for (const [dir, desc] of Object.entries(this.structure)) {
      const dirPath = path.join(ROOT, dir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        this.organized.created.push(dir);
      }
    }
  }

  // Catégoriser script par contenu
  categorizeScript(filePath) {
    const content = fs.readFileSync(filePath, 'utf8');
    const filename = path.basename(filePath).toLowerCase();

    // Analyse du contenu et du nom
    if (filename.includes('orchestrat') || filename.includes('master') || filename.includes('ultimate')) {
      return 'scripts/core';
    }
    if (filename.includes('auto') || filename.includes('cron') || content.includes('setInterval')) {
      return 'scripts/automation';
    }
    if (filename.includes('validat') || filename.includes('check') || filename.includes('coherence')) {
      return 'scripts/validation';
    }
    if (filename.includes('enrich') || filename.includes('battery') || filename.includes('flow')) {
      return 'scripts/enrichment';
    }
    if (filename.includes('organiz') || filename.includes('clean') || filename.includes('structure')) {
      return 'scripts/organization';
    }
    if (filename.includes('fix') || filename.includes('repair') || filename.includes('maintain')) {
      return 'scripts/maintenance';
    }
    if (filename.includes('deploy') || filename.includes('publish') || filename.includes('release')) {
      return 'scripts/deployment';
    }
    if (filename.includes('monitor') || filename.includes('watch') || filename.includes('track')) {
      return 'scripts/monitoring';
    }
    if (filename.includes('scrap') || filename.includes('fetch') || filename.includes('download')) {
      return 'scripts/tools';
    }

    // Par défaut
    return 'scripts/tools';
  }

  // Organiser scripts
  organizeScripts() {
    this.log('Organisation scripts...', '📜');
    
    const scriptsPath = path.join(ROOT, 'scripts');
    const files = fs.readdirSync(scriptsPath);

    for (const file of files) {
      const filePath = path.join(scriptsPath, file);
      const stat = fs.statSync(filePath);

      // Ignorer dossiers et modules
      if (stat.isDirectory() || file === 'modules') continue;
      if (!file.endsWith('.js')) continue;

      // Catégoriser
      const category = this.categorizeScript(filePath);
      const targetPath = path.join(ROOT, category, file);

      // Déplacer si pas déjà au bon endroit
      if (path.dirname(filePath) !== path.join(ROOT, category)) {
        if (!fs.existsSync(targetPath)) {
          fs.renameSync(filePath, targetPath);
          this.organized.scripts.push({
            file,
            from: 'scripts/',
            to: category
          });
          this.log(`${file} → ${category}`, '  ✅');
        }
      }
    }
  }

  // Générer index pour chaque catégorie
  generateIndexes() {
    this.log('Génération index...', '📑');

    for (const dir of Object.keys(this.structure)) {
      const dirPath = path.join(ROOT, dir);
      if (!fs.existsSync(dirPath)) continue;

      const files = fs.readdirSync(dirPath).filter(f => f.endsWith('.js'));
      if (files.length === 0) continue;

      const indexContent = `#!/usr/bin/env node
'use strict';

/**
 * INDEX - ${this.structure[dir]}
 * Auto-generated by UltimateProjectOrganizer
 */

${files.map(f => {
  const name = path.basename(f, '.js');
  return `const ${name} = require('./${f}');`;
}).join('\n')}

module.exports = {
${files.map(f => '  ' + path.basename(f, '.js')).join(',\n')}
};
`;

      const indexPath = path.join(dirPath, 'index.js');
      fs.writeFileSync(indexPath, indexContent);
      this.log(`Index créé: ${dir}/index.js`, '  ✅');
    }
  }

  // Créer README pour chaque catégorie
  generateReadmes() {
    this.log('Génération READMEs...', '📖');

    for (const [dir, desc] of Object.entries(this.structure)) {
      const dirPath = path.join(ROOT, dir);
      if (!fs.existsSync(dirPath)) continue;

      const files = fs.readdirSync(dirPath).filter(f => f.endsWith('.js') && f !== 'index.js');
      if (files.length === 0) continue;

      const readmeContent = `# ${desc}

## Scripts disponibles

${files.map(f => {
  return `### ${f}\n\n\`\`\`bash\nnode ${dir}/${f}\n\`\`\`\n`;
}).join('\n')}

## Utilisation

Tous les scripts peuvent être importés via l'index:

\`\`\`javascript
const ${path.basename(dir)} = require('./${dir}');
\`\`\`
`;

      const readmePath = path.join(dirPath, 'README.md');
      fs.writeFileSync(readmePath, readmeContent);
    }
  }

  // Générer rapport
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      structure: this.structure,
      organized: {
        scripts: this.organized.scripts.length,
        created: this.organized.created.length,
        moved: this.organized.moved.length
      },
      files: this.organized
    };

    const reportPath = path.join(ROOT, 'reports', 'PROJECT_ORGANIZATION_REPORT.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    return report;
  }

  // Exécution
  async run() {
    console.log('\n╔════════════════════════════════════════════════════════════════════╗');
    console.log('║                                                                    ║');
    console.log('║     ULTIMATE PROJECT ORGANIZER - ORGANISATION COMPLÈTE             ║');
    console.log('║                                                                    ║');
    console.log('╚════════════════════════════════════════════════════════════════════╝\n');

    const startTime = Date.now();

    // Exécuter organisation
    this.createStructure();
    this.organizeScripts();
    this.generateIndexes();
    this.generateReadmes();
    
    const report = this.generateReport();
    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);

    // Résumé
    console.log('\n' + '═'.repeat(70));
    console.log('📊 RÉSUMÉ ORGANISATION');
    console.log('═'.repeat(70));
    console.log(`\n⏱️  Temps: ${totalTime}s`);
    console.log(`📁 Dossiers créés: ${this.organized.created.length}`);
    console.log(`📜 Scripts organisés: ${this.organized.scripts.length}`);
    console.log(`📑 Index générés: ${Object.keys(this.structure).length}`);

    console.log('\n' + '═'.repeat(70));
    console.log('✅ ORGANISATION TERMINÉE');
    console.log('═'.repeat(70) + '\n');

    return report;
  }
}

// Exécuter
if (require.main === module) {
  const organizer = new UltimateProjectOrganizer();
  organizer.run().catch(err => {
    console.error('Erreur fatale:', err);
    process.exit(1);
  });
}

module.exports = UltimateProjectOrganizer;
