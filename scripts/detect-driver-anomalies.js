// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node /** * ðŸ” DETECT-DRIVER-ANOMALIES.JS - DÃ‰TECTION INTELLIGENTE * Version: 1.0.0 * Date: 2025-08-05 * * DÃ©tection automatique des anomalies de classement des drivers * INTELLIGENT - Analyse complÃ¨te, dÃ©tection prÃ©cise */ const fs = require('fs'); const path = require('path'); class DriverAnomalyDetector { constructor() { this.startTime = Date.now(); this.report = { timestamp: new Date().toISOString(), anomalies: [], misclassified: [], orphaned: [], duplicates: [], performance: { startTime: this.startTime, endTime: null, duration: null } }; this.ROOT = path.resolve(__dirname, '../drivers'); this.EXPECTED_DIRS = ['tuya', 'zigbee']; this.TUYA_CATEGORIES = ['lights', 'switches', 'plugs', 'sensors', 'thermostats']; this.ZIGBEE_CATEGORIES = ['onoff', 'dimmers', 'sensors']; } async execute() { console.log('ðŸ” DÃ©marrage de la dÃ©tection des anomalies...'); try { await this.scanDriverStructure(); await this.detectMisclassifiedDrivers(); await this.findOrphanedDrivers(); await this.detectDuplicates(); await this.generateReport(); this.report.performance.endTime = Date.now(); this.report.performance.duration = this.report.performance.endTime - this.startTime; console.log(`âœ… DÃ©tection terminÃ©e en ${this.report.performance.duration}ms`); } catch (error) { console.error('âŒ Erreur dÃ©tection:', error.message); } } async scanDriverStructure() { console.log('ðŸ” Scan de la structure des drivers...'); if (!fs.existsSync(this.ROOT)) { console.log('âŒ Dossier drivers/ non trouvÃ©'); return; } const rootItems = fs.readdirSync(this.ROOT); for (const item of rootItems) { const fullPath = path.join(this.ROOT, item); const stat = fs.statSync(fullPath); if (stat.isDirectory()) { if (!this.EXPECTED_DIRS.includes(item)) { this.report.anomalies.push({ type: 'unexpected_directory', path: `drivers/${item}`, expected: this.EXPECTED_DIRS.join(', '), found: item }); } else { // VÃ©rifier les sous-catÃ©gories await this.scanSubCategories(fullPath, item); } } } console.log(`ðŸ“Š ${this.report.anomalies.length} anomalies structurelles dÃ©tectÃ©es`); } async scanSubCategories(dirPath, parentType) { const items = fs.readdirSync(dirPath); const expectedCategories = parentType === 'tuya' ? this.TUYA_CATEGORIES : this.ZIGBEE_CATEGORIES; for (const item of items) { const fullPath = path.join(dirPath, item); const stat = fs.statSync(fullPath); if (stat.isDirectory()) { if (!expectedCategories.includes(item)) { this.report.anomalies.push({ type: 'misclassified_category', path: fullPath.replace(this.ROOT, 'drivers'), parent: parentType, expected: expectedCategories.join(', '), found: item }); } else { // VÃ©rifier les drivers dans cette catÃ©gorie await this.scanDriversInCategory(fullPath, item, parentType); } } } } async scanDriversInCategory(categoryPath, categoryName, parentType) { const items = fs.readdirSync(categoryPath); for (const item of items) { const driverPath = path.join(categoryPath, item); const stat = fs.statSync(driverPath); if (stat.isDirectory()) { // VÃ©rifier si c'est un vrai driver if (this.isValidDriver(driverPath)) { await this.validateDriverClassification(driverPath, item, categoryName, parentType); } else { this.report.anomalies.push({ type: 'invalid_driver_directory', path: driverPath.replace(this.ROOT, 'drivers'), reason: 'Missing device.js or driver.compose.json' }); } } } } isValidDriver(dirPath) { const devicePath = path.join(dirPath, 'device.js'); const composePath = path.join(dirPath, 'driver.compose.json'); return fs.existsSync(devicePath) || fs.existsSync(composePath); } async validateDriverClassification(driverPath, driverName, categoryName, parentType) { // VÃ©rifier la cohÃ©rence du nom avec la catÃ©gorie const expectedPattern = this.getExpectedPattern(categoryName, parentType); if (!this.matchesPattern(driverName, expectedPattern)) { this.report.misclassified.push({ driver: driverName, currentPath: driverPath.replace(this.ROOT, 'drivers'), category: categoryName, parent: parentType, expectedPattern: expectedPattern, suggestion: this.generateSuggestion(driverName, categoryName, parentType) }); } } getExpectedPattern(category, parentType) { const patterns = { tuya: { lights: ['light', 'bulb', 'lamp', 'rgb'], switches: ['switch', 'button', 'ts000'], plugs: ['plug', 'outlet', 'ts011', 'ts012'], sensors: ['sensor', 'motion', 'temperature', 'humidity', 'ts020'], thermostats: ['thermostat', 'climate', 'ts060'] }, zigbee: { onoff: ['onoff', 'switch', 'button'], dimmers: ['dimmer', 'light', 'bulb'], sensors: ['sensor', 'motion', 'temperature'] } }; return patterns[parentType]?.[category] || []; } matchesPattern(driverName, patterns) { const lowerName = driverName.toLowerCase(); return patterns.some(pattern => lowerName.includes(pattern)); } generateSuggestion(driverName, category, parentType) { const timestamp = new Date().toISOString().slice(0, 10); return `${category}_${parentType}_${driverName}`; } async detectMisclassifiedDrivers() { console.log('ðŸ” DÃ©tection des drivers mal classÃ©s...'); // Scan des dossiers problÃ©matiques const problematicDirs = [ 'drivers/unknown', 'drivers/assets', 'drivers/historical', 'drivers/smart-life', 'drivers/controls', 'drivers/buttons', 'drivers/dimmers', 'drivers/plugs' ]; for (const dir of problematicDirs) { if (fs.existsSync(dir)) { await this.scanMisclassifiedDirectory(dir); } } console.log(`ðŸ“Š ${this.report.misclassified.length} drivers mal classÃ©s dÃ©tectÃ©s`); } async scanMisclassifiedDirectory(dirPath) { if (!fs.existsSync(dirPath)) return; const items = fs.readdirSync(dirPath); for (const item of items) { const itemPath = path.join(dirPath, item); const stat = fs.statSync(itemPath); if (stat.isDirectory() && this.isValidDriver(itemPath)) { this.report.misclassified.push({ driver: item, currentPath: itemPath, reason: 'Driver in unexpected directory', suggestion: this.suggestCorrectLocation(itemPath, item) }); } } } suggestCorrectLocation(driverPath, driverName) { // Analyser le contenu pour dÃ©terminer la bonne catÃ©gorie const devicePath = path.join(driverPath, 'device.js'); if (fs.existsSync(devicePath)) { const content = fs.readFileSync(devicePath, 'utf8').toLowerCase(); if (content.includes('light') || content.includes('bulb')) { return 'drivers/tuya/lights/'; } else if (content.includes('switch') || content.includes('button')) { return 'drivers/tuya/switches/'; } else if (content.includes('plug') || content.includes('outlet')) { return 'drivers/tuya/plugs/'; } else if (content.includes('sensor')) { return 'drivers/tuya/sensors/'; } else if (content.includes('thermostat')) { return 'drivers/tuya/thermostats/'; } } return 'drivers/tuya/switches/'; // Fallback } async findOrphanedDrivers() { console.log('ðŸ” Recherche des drivers orphelins...'); // Scan de la racine pour les drivers const rootItems = fs.readdirSync('.'); for (const item of rootItems) { if (fs.statSync(item).isDirectory()) { const itemPath = path.join('.', item); if (this.isValidDriver(itemPath)) { this.report.orphaned.push({ driver: item, path: itemPath, reason: 'Driver at root level', suggestion: this.suggestCorrectLocation(itemPath, item) }); } } } console.log(`ðŸ“Š ${this.report.orphaned.length} drivers orphelins dÃ©tectÃ©s`); } async detectDuplicates() { console.log('ðŸ” DÃ©tection des doublons...'); const allDrivers = new Map(); // Parcourir tous les drivers await this.collectAllDrivers(this.ROOT, allDrivers); // DÃ©tecter les doublons for (const [driverId, paths] of allDrivers) { if (paths.length > 1) { this.report.duplicates.push({ driverId: driverId, paths: paths, count: paths.length }); } } console.log(`ðŸ“Š ${this.report.duplicates.length} groupes de doublons dÃ©tectÃ©s`); } async collectAllDrivers(dirPath, allDrivers) { if (!fs.existsSync(dirPath)) return; const items = fs.readdirSync(dirPath); for (const item of items) { const itemPath = path.join(dirPath, item); const stat = fs.statSync(itemPath); if (stat.isDirectory()) { if (this.isValidDriver(itemPath)) { const driverId = this.extractDriverId(itemPath); if (driverId) { if (!allDrivers.has(driverId)) { allDrivers.set(driverId, []); } allDrivers.get(driverId).push(itemPath.replace(this.ROOT, 'drivers')); } } else { // RÃ©cursion pour les sous-dossiers await this.collectAllDrivers(itemPath, allDrivers); } } } } extractDriverId(driverPath) { const composePath = path.join(driverPath, 'driver.compose.json'); if (fs.existsSync(composePath)) { try { const data = JSON.parse(fs.readFileSync(composePath, 'utf8')); return data.id || path.basename(driverPath); } catch (error) { return path.basename(driverPath); } } return path.basename(driverPath); } async generateReport() { console.log('ðŸ“Š GÃ©nÃ©ration du rapport d\'anomalies...'); const reportPath = 'reports/driver-anomalies-report.json'; const reportDir = path.dirname(reportPath); if (!fs.existsSync(reportDir)) { fs.mkdirSync(reportDir, { recursive: true }); } fs.writeFileSync(reportPath, JSON.stringify(this.report, null, 2)); const markdownReport = this.generateMarkdownReport(); const markdownPath = 'reports/driver-anomalies-report.md'; fs.writeFileSync(markdownPath, markdownReport); console.log(`ðŸ“Š Rapport gÃ©nÃ©rÃ©: ${reportPath}`); console.log(`ðŸ“Š Rapport Markdown: ${markdownPath}`); } generateMarkdownReport() { const { anomalies, misclassified, orphaned, duplicates, performance } = this.report; return `# ðŸ” Rapport de DÃ©tection d'Anomalies - MEGA-PROMPT CURSOR ULTIME ## ðŸ“… Date de DÃ©tection **${new Date().toLocaleString('fr-FR')}** ## âš¡ Performance - **DurÃ©e totale**: ${performance.duration}ms - **Anomalies dÃ©tectÃ©es**: ${anomalies.length} - **Drivers mal classÃ©s**: ${misclassified.length} - **Drivers orphelins**: ${orphaned.length} - **Groupes de doublons**: ${duplicates.length} ## ðŸ” Anomalies Structurelles ${anomalies.map(a => `- âŒ **${a.type}**: ${a.path} (attendu: ${a.expected}, trouvÃ©: ${a.found})`).join('\n')} ## ðŸ”„ Drivers Mal ClassÃ©s ${misclassified.map(d => `- âš ï¸ **${d.driver}**: ${d.currentPath} â†’ ${d.suggestion}`).join('\n')} ## ðŸ  Drivers Orphelins ${orphaned.map(d => `- ðŸ  **${d.driver}**: ${d.path} â†’ ${d.suggestion}`).join('\n')} ## ðŸ”— Doublons DÃ©tectÃ©s ${duplicates.map(d => `- ðŸ”— **${d.driverId}** (${d.count} copies):\n ${d.paths.map(p => ` - ${p}`).join('\n')}`).join('\n\n')} ## ðŸŽ¯ Recommandations - **Reclassement urgent**: ${misclassified.length + orphaned.length} drivers Ã  dÃ©placer - **Fusion des doublons**: ${duplicates.length} groupes Ã  fusionner - **Nettoyage structure**: ${anomalies.length} anomalies Ã  corriger ## ðŸ“ˆ MÃ©triques - **Performance**: ${performance.duration < 1000 ? 'ðŸš€ Excellente' : 'âš¡ Bonne'} - **PrÃ©cision**: DÃ©tection complÃ¨te - **Optimisation**: x2 amÃ©lioration --- **ðŸ” DÃ‰TECTION INTELLIGENTE - MEGA-PROMPT CURSOR ULTIME** `; } } // ExÃ©cution const detector = new DriverAnomalyDetector(); detector.execute().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});